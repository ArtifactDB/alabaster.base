---
title: Defining an _alabaster_ schema
author:
- name: Aaron Lun
  email: luna@gene.com
  affiliation: gRED B&CB
package: alabaster.base
date: "Revised: December 10, 2021"
output:
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Schema overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Minimal requirements

All schemas should follow the [JSON web schema standard](https://json-schema.org/).

`$id` should follow a `<artifact_name>/<version>.json` format.
Currently, we are on version 2, so the `data_frame` schema would look like `data_frame/v2.json`.

`title` and `description` should provide an informative title and description of the artifact.

The `properties` should define the `$schema`, `path` and `is_child` properties.
This is most easily done by including [`_common/v2.json`](https://code.roche.com/GP/artifactdb-schema-templates/-/raw/master/raw/_common/v2.json) in an `allOf`.

For schemas that do not define pure metadata artifacts, the `properties` should contain the `md5sum` property.
This is most easily done by including [`_md5sum/v2.json`](https://code.roche.com/GP/artifactdb-schema-templates/-/raw/master/raw/_md5sum/v2.json) in an `allOf`.

Finally, the `properties` should contain a property with the same name as the schema, i.e., `<artifact_name>` 
This should be a JSON object and should be _required_.
So, for example, a hypothetical `BLAH` schema would contain a `BLAH` property in which all `BLAH`-specific properties are nested, 
avoiding any conflicts in names across different schemas when using tools like Elasticsearch.

```json
{
    "$schema": "http://json-schema.org/draft-07/schema",
    "$id": "BLAH/v2.json",
    "type": "object",
    "title": "blah",
    "description": "I am a blah.",
    "required": [
        "BLAH"
    ],
    "properties": {
        "BLAH": {
            "type": "object",
            "required": [
                "prop1"
            ],
            "properties": {
                "prop1": {
                    "type": "string",
                    "description": "First property"
                },
                "prop2": {
                    "type": "string",
                    "description": "Second property"
                }
            }
        }
    }
}
```

# Handling children

Metadata may contain references to other artifacts in the same project directory, i.e., "children". 
(In the _alabaster.\*_ context, the project directory is equivalent to the staging directory.)
In the schema, this requires the specification of a `resource` property to store the path to the other artifact.
This is most easily done by including [`_resource/v2.json`](https://code.roche.com/GP/artifactdb-schema-templates/-/raw/master/raw/_md5sum/v2.json) 
in an `allOf` in the relevant part of the schema - for example, `prop3` points to a child artifact below.

```json
{
    "$schema": "http://json-schema.org/draft-07/schema",
    "$id": "BLAH/v2.json",
    "type": "object",
    "title": "blah",
    "description": "I am a blah.",
    "required": [
        "BLAH"
    ],
    "properties": {
        "BLAH": {
            "type": "object",
            "required": [
                "prop1"
            ],
            "properties": {
                "prop1": {
                    "type": "string",
                    "description": "First property"
                },
                "prop2": {
                    "type": "string",
                    "description": "Second property"
                },
                "prop3": {
                    "type": "object",
                    "description": "Pointer to something",
                    "allOf": [ { "$ref": "../_resource/v2.json" } ]
                }
            }
        }
    }
}
```

Developers may optionally specify the nature of the children by defining a `_children` object within the `resource`.
`_children.contains` is a string array that specifies all of the allowable types that can be used as a child in that part of the schema.
To illustrate, say that `prop3` needs to refer to a `data_frame` - we could implement this restriction with the following schema:

```json
{
    "$schema": "http://json-schema.org/draft-07/schema",
    "$id": "BLAH/v2.json",
    "type": "object",
    "title": "blah",
    "description": "I am a blah.",
    "required": [
        "BLAH"
    ],
    "properties": {
        "BLAH": {
            "type": "object",
            "required": [
                "prop1"
            ],
            "properties": {
                "prop1": {
                    "type": "string",
                    "description": "First property"
                },
                "prop2": {
                    "type": "string",
                    "description": "Second property"
                },
                "prop3": {
                    "type": "object",
                    "description": "Pointer to something",
                    "properties": {
                        "resource": {
                            "_children": {
                                "contains": [ "data_frame" ]
                            }
                        }
                    },
                    "allOf": [ { "$ref": "../_resource/v2.json" } ]
                }
            }
        }
    }
}
```

This mark-up allows schema-traversing tools to easily determine what can or cannot be used as a child of a particular artifact.

# Defining attributes

Developers may define an `_attributes` field at the top-level. 
This should be a JSON object and may contain any number of these fields:

- `restore`, a JSON object containing restoration commands for one of more languages.
  For R, we expect a string containing a namespaced function that will be called by `alabaster.base::loadObject()`.
  This attribute is used by the _alabaster.\*_ framework to determine how to load artifacts back into an R session.
- `metadata_only`, a boolean indicating whether this schema describes a metadata-only artifact.
  If `true`, the `path` should point to the JSON metadata file rather than another file.
  This attribute is used by the _alabaster.\*_ framework to determine whether MD5 checksums need to be computed/validated.
  Defaults to `false` if not specified.
- `format`, a string containing the expected MIME type for artifacts of this type.
  This is largely ceremonial.

For example, the schema below tells us that we need to use `alabaster.blah::loadBlah` to obtain an R object from this artifact.

```json
{
    "$schema": "http://json-schema.org/draft-07/schema",
    "$id": "BLAH/v1.json",
    "type": "object",
    "title": "blah",
    "description": "I am a blah.",
    "required": [
        "BLAH"
    ],
    "properties": {
        "BLAH": {
            "type": "object",
            "required": [
                "prop1"
            ],
            "properties": {
                "prop1": {
                    "type": "string",
                    "description": "First property"
                },
                "prop2": {
                    "type": "string",
                    "description": "Second property"
                }
            }
        }
    },
    "_attributes": {
        "restore": {
            "R": "alabaster.blah::loadBlah"
        }
    }
}
```

# Mimicking inheritance

We mimic inheritance (in the object-orientated sense of the word) from one schema to a more specialized schema by using `allOf` and `$ref` statements.
This requires any document to validate against the specified parent schema as well as the current schema.
For example, we could "inherit" from `summarized_experiment/v2.json` with the following:

```json
{
    "$schema": "http://json-schema.org/draft-07/schema",
    "$id": "special_summarized_experiment/v2.json",
    "type": "object",
    "title": "Special summarized experiment",
    "description": "blah blah balh",
    "allOf": [ { "$ref": "../summarized_experiment/v2.json" }]

    "required": [ "special_summarized_experiment" ],
    "properties": {
        "special_summarized_experiment": {
            "type": "object",
            "properties": {
                "placeholder": {
                    "type": "boolean",
                    "description": "A placeholder."
                }
            }
        }
    }
}
```

Note that we should have a scoped `special_summarized_experiment` property.
This allows us to capture the schema hierarchy inside each document so that interfaces can operate on different levels of specialization.
For example, if we subsequently inherited from this schema, we would still have a `special_summarized_experiment` property in the document to indicate that the resource could be interpreted as a `special_summarized_experiment`.
This scoped property should be non-empty to ensure that some tools do not remove it - 
if we don't have any additional properties to add, we should add a placeholder as described above.
