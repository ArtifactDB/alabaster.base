% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loadDataFrame.R
\name{loadDataFrame}
\alias{loadDataFrame}
\title{Load a DataFrame}
\usage{
loadDataFrame(info, project, include.nested = TRUE, parallel = TRUE)
}
\arguments{
\item{info}{Named list containing the metadata for this object.}

\item{project}{Any argument accepted by the acquisition functions, see \code{?\link{acquireFile}}.
By default, this should be a string containing the path to a staging directory.}

\item{include.nested}{Logical scalar indicating whether nested \linkS4class{DataFrame}s should be loaded.}

\item{parallel}{Whether to perform reading and parsing in parallel for greater speed.}
}
\value{
The DataFrame described by \code{info}.
}
\description{
Load a \linkS4class{DataFrame} from file, possibly containing complex columns and row names.
}
\details{
This function effectively reverses the behavior of \code{\link{stageObject}}, 
loading the \linkS4class{DataFrame} back into memory from the CSV or HDF5 file.
Atomic columns are loaded directly while complex columns (such as nested DataFrames) are loaded by calling the appropriate \code{restore} method.

One implicit interpretation of using a nested DataFrame is that the contents are not important enough to warrant top-level columns.
In such cases, we can skip all columns containing a nested DataFrame by setting \code{include.nested=FALSE}.
This avoids the cost of loading a (potentially large) nested DataFrame when its contents are unlikely to be relevant.
}
\examples{
library(S4Vectors)
df <- DataFrame(A=1:10, B=LETTERS[1:10])

# First staging it:
tmp <- tempfile()
dir.create(tmp)
out <- stageObject(df, tmp, path="coldata")

# And now loading it:
loadDataFrame(out, tmp)

}
\author{
Aaron Lun
}
